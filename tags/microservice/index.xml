<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>microservice on Jacob Martin</title>
    <link>https://examplesite.com/tags/microservice/</link>
    <description>Recent content in microservice on Jacob Martin</description>
    <image>
      <url>https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://examplesite.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 29 Jan 2017 11:24:18 +0000</lastBuildDate><atom:link href="https://examplesite.com/tags/microservice/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Practical Golang: Building a simple, distributed one-value database with Hashicorp Serf</title>
      <link>https://examplesite.com/2017/01/29/practical-golang-building-a-simple-distributed-one-value-database-with-hashicorp-serf/</link>
      <pubDate>Sun, 29 Jan 2017 11:24:18 +0000</pubDate>
      
      <guid>https://examplesite.com/2017/01/29/practical-golang-building-a-simple-distributed-one-value-database-with-hashicorp-serf/</guid>
      <description>Introduction With the advent of distributed applications, we see new storage solutions emerging constantly.
They include, but are not limited to, Cassandra, Redis, CockroachDB, Consul or RethinkDB.
Most of you probably use one, or more, of them.
They seem to be really complex systems, because they actually are. This can’t be denied.
But it’s pretty easy to write a simple, one value database, featuring high availability.
You probably wouldn’t use anything near this in production, but it should be a fruitful learning experience for you nevertheless.</description>
    </item>
    
    <item>
      <title>Practical Golang: Getting started with NATS and related patterns</title>
      <link>https://examplesite.com/2016/06/06/practical-golang-getting-started-with-nats-and-related-patterns/</link>
      <pubDate>Mon, 06 Jun 2016 11:51:48 +0000</pubDate>
      
      <guid>https://examplesite.com/2016/06/06/practical-golang-getting-started-with-nats-and-related-patterns/</guid>
      <description>Practical Golang: Getting started with NATS and related patterns Introduction Microservices… the never disappearing buzzword of our times. They promise a lot, but can be slow or complicated if not implemented correctly. One of the main challenges when developing and using a microservice-based architecture is getting the communication right. Many will ask, why not REST? As I did at some point. Many will actually use it. But the truth is that it leads to tighter coupling, and is synchronous.</description>
    </item>
    
    <item>
      <title>Practical Golang: Event multicast/subscription service</title>
      <link>https://examplesite.com/2016/04/04/practical-golang-event-multicastsubscription-service/</link>
      <pubDate>Mon, 04 Apr 2016 10:30:24 +0000</pubDate>
      
      <guid>https://examplesite.com/2016/04/04/practical-golang-event-multicastsubscription-service/</guid>
      <description>Introduction In our microservice architectures we always need a method for communicating between services. There are various ways to achieve this. Few of them are, but are not limited to: Remote Procedure Call, REST API’s, message BUSses. In this comprehensive tutorial we’ll write a service, which you can use to distribute messages/events across your system.
Design How will it work? It will accept registering subscribers (other microservices). Whenever it gets a message from a microservice, it will send it further to all subscribers, using a REST call to the other microservices /event URL.</description>
    </item>
    
    <item>
      <title>Web app using Microservices in Go: Part 4 – Worker and Frontend</title>
      <link>https://examplesite.com/2016/03/23/web-app-using-microservices-in-go-part-4-worker-and-frontend/</link>
      <pubDate>Wed, 23 Mar 2016 13:34:03 +0000</pubDate>
      
      <guid>https://examplesite.com/2016/03/23/web-app-using-microservices-in-go-part-4-worker-and-frontend/</guid>
      <description>Previous part
Introduction In this part we will finally finish writing our application. We will implement the last two services:
 The Worker The Frontend  The Worker The worker will communicate with the Master to get new Tasks. When it gets a Task it will get the corresponding data from the storage and will start working on the task. When it finishes it will send the finished data to the storage service, and if that succeeds it will register the Task as finished to the Master.</description>
    </item>
    
    <item>
      <title>Web app using Microservices in Go: Part 3 – Storage and Master</title>
      <link>https://examplesite.com/2016/03/21/web-app-using-microservices-in-go-part-3-storage-and-master/</link>
      <pubDate>Mon, 21 Mar 2016 13:25:39 +0000</pubDate>
      
      <guid>https://examplesite.com/2016/03/21/web-app-using-microservices-in-go-part-3-storage-and-master/</guid>
      <description>Previous part
Introduction In this part we will implement the next part of the microservices needed for our web app. We will implement the:
 Storage system Master  This way we will have the Master API ready when we’ll be writing the slaves/workers and the frontend. And we’ll already have the database, k/v store and storage when writing the master. SO every time we write something we’ll already have all its dependencies.</description>
    </item>
    
    <item>
      <title>Web app using Microservices in Go: Part 2 – k/v store and Database</title>
      <link>https://examplesite.com/2016/03/16/web-app-using-microservices-in-go-part-2-kv-store-and-database/</link>
      <pubDate>Wed, 16 Mar 2016 12:30:40 +0000</pubDate>
      
      <guid>https://examplesite.com/2016/03/16/web-app-using-microservices-in-go-part-2-kv-store-and-database/</guid>
      <description>Previous part
Introduction In this part we will implement part of the microservices needed for our web app. We will implement the:
 key-value store Database  This will be a pretty code heavy tutorial so concentrate and have fun!
The key-value store Design The design hasn’t changed much. We will save the key-value pairs as a global map, and create a global mutex for concurrent access. We’ll also add the ability to list all key-value pairs for debugging/analytical purposes.</description>
    </item>
    
    <item>
      <title>Web app using Microservices in Go: Part 1 – Design</title>
      <link>https://examplesite.com/2016/03/14/web-app-using-microservices-in-go-part-1-design/</link>
      <pubDate>Mon, 14 Mar 2016 14:19:19 +0000</pubDate>
      
      <guid>https://examplesite.com/2016/03/14/web-app-using-microservices-in-go-part-1-design/</guid>
      <description>Introduction Recently it’s a constantly repeated buzzword – Microservices. You can love ’em or hate ’em, but you really shouldn’t ignore ’em. In this short series we’ll create a web app using a microservice architecture. We’ll try not to use 3rd party tools and libraries. Remember though that when creating a production web app it is highly recommended to use 3rd party libraries (even if only to save you time).</description>
    </item>
    
  </channel>
</rss>
