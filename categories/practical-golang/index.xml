<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Practical Golang on Jacob Martin</title>
    <link>https://kubamartin.com/categories/practical-golang/</link>
    <description>Recent content in Practical Golang on Jacob Martin</description>
    <image>
      <title>Jacob Martin</title>
      <url>https://kubamartin.com/images/avatar.jpg</url>
      <link>https://kubamartin.com/images/avatar.jpg</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 29 Jan 2017 11:24:18 +0000</lastBuildDate><atom:link href="https://kubamartin.com/categories/practical-golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Practical Golang: Building a simple, distributed one-value database with Hashicorp Serf</title>
      <link>https://kubamartin.com/2017/01/29/practical-golang-building-a-simple-distributed-one-value-database-with-hashicorp-serf/</link>
      <pubDate>Sun, 29 Jan 2017 11:24:18 +0000</pubDate>
      
      <guid>https://kubamartin.com/2017/01/29/practical-golang-building-a-simple-distributed-one-value-database-with-hashicorp-serf/</guid>
      <description>Introduction With the advent of distributed applications, we see new storage solutions emerging constantly.
They include, but are not limited to, Cassandra, Redis, CockroachDB, Consul or RethinkDB.
Most of you probably use one, or more, of them.
They seem to be really complex systems, because they actually are. This can’t be denied.
But it’s pretty easy to write a simple, one value database, featuring high availability.
You probably wouldn’t use anything near this in production, but it should be a fruitful learning experience for you nevertheless.</description>
    </item>
    
    <item>
      <title>Practical Golang: Getting started with NATS and related patterns</title>
      <link>https://kubamartin.com/2016/06/06/practical-golang-getting-started-with-nats-and-related-patterns/</link>
      <pubDate>Mon, 06 Jun 2016 11:51:48 +0000</pubDate>
      
      <guid>https://kubamartin.com/2016/06/06/practical-golang-getting-started-with-nats-and-related-patterns/</guid>
      <description>Practical Golang: Getting started with NATS and related patterns Introduction Microservices… the never disappearing buzzword of our times. They promise a lot, but can be slow or complicated if not implemented correctly. One of the main challenges when developing and using a microservice-based architecture is getting the communication right. Many will ask, why not REST? As I did at some point. Many will actually use it. But the truth is that it leads to tighter coupling, and is synchronous.</description>
    </item>
    
    <item>
      <title>Practical Golang: Using Protobuffs</title>
      <link>https://kubamartin.com/2016/05/24/practical-golang-using-protobuffs/</link>
      <pubDate>Tue, 24 May 2016 11:44:26 +0000</pubDate>
      
      <guid>https://kubamartin.com/2016/05/24/practical-golang-using-protobuffs/</guid>
      <description>Introduction Most apps we make need a means of communication. We usually use JSON, or just plain text. JSON has got especially popular because of the rise of Node.js. The truth though, is, that JSON isn’t really a fast format. The marshaller in Go also isn’t that fast. That’s why in this article we’ll learn how to use google protocol buffers. They are in fact very easy to use, and are much faster than JSON.</description>
    </item>
    
    <item>
      <title>Practical Golang: Writing a simple login middleware</title>
      <link>https://kubamartin.com/2016/04/06/practical-golang-writing-a-simple-login-middleware/</link>
      <pubDate>Wed, 06 Apr 2016 11:08:18 +0000</pubDate>
      
      <guid>https://kubamartin.com/2016/04/06/practical-golang-writing-a-simple-login-middleware/</guid>
      <description>Introduction In this part we’ll be creating a simple middleware you can easily apply to your handlers to get authentication/authorization. Middleware like this is an awesome way to add additional functionality to your Go server. Here we will only do authorization as we will only ask for a password, not a login. Although if you want, then you can easily extend this system to any authentication/authorization you’d like.
Implementation We will mainly use the stdlib, and will use cookies to remember who’s already logged in.</description>
    </item>
    
    <item>
      <title>Practical Golang: Event multicast/subscription service</title>
      <link>https://kubamartin.com/2016/04/04/practical-golang-event-multicastsubscription-service/</link>
      <pubDate>Mon, 04 Apr 2016 10:30:24 +0000</pubDate>
      
      <guid>https://kubamartin.com/2016/04/04/practical-golang-event-multicastsubscription-service/</guid>
      <description>Introduction In our microservice architectures we always need a method for communicating between services. There are various ways to achieve this. Few of them are, but are not limited to: Remote Procedure Call, REST API’s, message BUSses. In this comprehensive tutorial we’ll write a service, which you can use to distribute messages/events across your system.
Design How will it work? It will accept registering subscribers (other microservices). Whenever it gets a message from a microservice, it will send it further to all subscribers, using a REST call to the other microservices /event URL.</description>
    </item>
    
    <item>
      <title>Practical Golang: Using Google Drive and Calendar</title>
      <link>https://kubamartin.com/2016/03/08/practical-golang-using-google-drive-and-calendar/</link>
      <pubDate>Tue, 08 Mar 2016 13:47:01 +0000</pubDate>
      
      <guid>https://kubamartin.com/2016/03/08/practical-golang-using-google-drive-and-calendar/</guid>
      <description>Introduction Integrating Google services into your app can lead to a lot of nice features for your users, and can create a seamless experience for them. In this tutorial we’ll learn how to use the most useful functionalities of Google Calendar and Google Drive.
The theory To begin with, we should understand the methodology of using the Google API in Golang. For most of their API’s I’ve skimmed through it works like that:</description>
    </item>
    
    <item>
      <title>Practical Golang: Using websockets</title>
      <link>https://kubamartin.com/2016/03/07/practical-golang-using-websockets/</link>
      <pubDate>Mon, 07 Mar 2016 13:23:50 +0000</pubDate>
      
      <guid>https://kubamartin.com/2016/03/07/practical-golang-using-websockets/</guid>
      <description>Introduction This is the first post in the practical Golang series. Posts in it are meant to provide short and informative introductions to various topics.
This one is a about websockets, which are an awesome and easy way to provide communication between your web app and server.
Here we will use the gorilla websocket library, but you could also use a few others.
We will create two basic apps which should cover most day to day usage:</description>
    </item>
    
  </channel>
</rss>
