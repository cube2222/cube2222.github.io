<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Web app using Microservices in Go: Part 3 – Storage and Master | Jacob Martin</title><meta name=keywords content="architecture,go,golang,image,master,microservice,storage,web app,worker"><meta name=description content="Previous part
Introduction In this part we will implement the next part of the microservices needed for our web app. We will implement the:
Storage system Master This way we will have the Master API ready when we’ll be writing the slaves/workers and the frontend. And we’ll already have the database, k/v store and storage when writing the master. SO every time we write something we’ll already have all its dependencies."><meta name=author content="Jacob Martin"><link rel=canonical href=https://kubamartin.com/2016/03/21/web-app-using-microservices-in-go-part-3-storage-and-master/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kubamartin.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kubamartin.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kubamartin.com/favicon-32x32.png><link rel=apple-touch-icon href=https://kubamartin.com/apple-touch-icon.png><link rel=mask-icon href=https://kubamartin.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-74339391-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Web app using Microservices in Go: Part 3 – Storage and Master"><meta property="og:description" content="Previous part
Introduction In this part we will implement the next part of the microservices needed for our web app. We will implement the:
Storage system Master This way we will have the Master API ready when we’ll be writing the slaves/workers and the frontend. And we’ll already have the database, k/v store and storage when writing the master. SO every time we write something we’ll already have all its dependencies."><meta property="og:type" content="article"><meta property="og:url" content="https://kubamartin.com/2016/03/21/web-app-using-microservices-in-go-part-3-storage-and-master/"><meta property="og:image" content="https://kubamartin.com/images/avatar.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-03-21T13:25:39+00:00"><meta property="article:modified_time" content="2016-03-21T13:25:39+00:00"><meta property="og:site_name" content="Jacob Martin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kubamartin.com/images/avatar.jpg"><meta name=twitter:title content="Web app using Microservices in Go: Part 3 – Storage and Master"><meta name=twitter:description content="Previous part
Introduction In this part we will implement the next part of the microservices needed for our web app. We will implement the:
Storage system Master This way we will have the Master API ready when we’ll be writing the slaves/workers and the frontend. And we’ll already have the database, k/v store and storage when writing the master. SO every time we write something we’ll already have all its dependencies."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kubamartin.com/posts/"},{"@type":"ListItem","position":2,"name":"Web app using Microservices in Go: Part 3 – Storage and Master","item":"https://kubamartin.com/2016/03/21/web-app-using-microservices-in-go-part-3-storage-and-master/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Web app using Microservices in Go: Part 3 – Storage and Master","name":"Web app using Microservices in Go: Part 3 – Storage and Master","description":"Previous part\nIntroduction In this part we will implement the next part of the microservices needed for our web app. We will implement the:\nStorage system Master This way we will have the Master API ready when we’ll be writing the slaves/workers and the frontend. And we’ll already have the database, k/v store and storage when writing the master. SO every time we write something we’ll already have all its dependencies.","keywords":["architecture","go","golang","image","master","microservice","storage","web app","worker"],"articleBody":"Previous part\nIntroduction In this part we will implement the next part of the microservices needed for our web app. We will implement the:\nStorage system Master This way we will have the Master API ready when we’ll be writing the slaves/workers and the frontend. And we’ll already have the database, k/v store and storage when writing the master. SO every time we write something we’ll already have all its dependencies.\nThe storage system Ok, this one will be pretty easy to write. Just handling files. Let’s build the basic structure, which will include a function to register in our k/v store. For reference how it works check out the previous part. So here’s the basic structure:\npackage main import ( \"fmt\" \"net/http\" \"io/ioutil\" \"os\" \"net/url\" \"io\" ) func main() { if !registerInKVStore() { return } http.HandleFunc(\"/sendImage\", receiveImage) http.HandleFunc(\"/getImage\", serveImage) http.ListenAndServe(\":3002\", nil) } func receiveImage(w http.ResponseWriter, r *http.Request) { } func serveImage(w http.ResponseWriter, r *http.Request) { } func registerInKVStore() bool { if len(os.Args) \u003c 3 { fmt.Println(\"Error: Too few arguments.\") return false } storageAddress := os.Args[1] // The address of itself keyValueStoreAddress := os.Args[2] response, err := http.Post(\"http://\" + keyValueStoreAddress + \"/set?key=storageAddress\u0026value=\" + storageAddress, \"\", nil) if err != nil { fmt.Println(err) return false } data, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(err) return false } if response.StatusCode != http.StatusOK { fmt.Println(\"Error: Failure when contacting key-value store: \", string(data)) return false } return true } So now we’ll have to handle the file serving/uploading. We will use a state url argument to specify if we are using the not yet finished (aka working) directory, or the finished one.\nSo first let’s write the receiveImage function which is there to get the files from clients:\nfunc receiveImage(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } if len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input id.\") return } if values.Get(\"state\") != \"working\" \u0026\u0026 values.Get(\"state\") != \"finished\" { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input state.\") return } } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } Here we check if the request method is POST, if there is an id, and if the state is working or finished.\nNext we can create the file and put in the image:\nif values.Get(\"state\") != \"working\" \u0026\u0026 values.Get(\"state\") != \"finished\" { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input state.\") return } _, err = strconv.Atoi(values.Get(\"id\")) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input id.\") return } file, err := os.Create(\"/tmp/\" + values.Get(\"state\") + \"/\" + values.Get(\"id\") + \".png\") defer file.Close() if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } _, err = io.Copy(file, r.Body) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } fmt.Fprint(w, \"success\") We create a file in the tmp/state directory with the right id. Another thing we do is check if the id really is a valid int. We parse it to an int, to see if it succeeds and if it does then we use it, as a string.\nwe use the io.Copy function to put all the data from the request to the file. That means that the body of our request should be a raw image.\nNext we can write the function to serve images which is pretty similar:\nfunc serveImage(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodGet { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } if len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input id.\") return } if values.Get(\"state\") != \"working\" \u0026\u0026 values.Get(\"state\") != \"finished\" { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input state.\") return } _, err = strconv.Atoi(values.Get(\"id\")) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input id.\") return } file, err := os.Open(\"/tmp/\" + values.Get(\"state\") + \"/\" + values.Get(\"id\") + \".png\") defer file.Close() if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } _, err = io.Copy(w, file) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only GET accepted\") } } Instead of creating the file, we open it. Instead of copying to the file we copy from it. And we check if the method is GET.\nThat’s it. We’ve got a storage service which saves and servers raw image files. Now we can get to the master!\nThe master We now have all the dependencies the master needs. So let’s write it now. Here’s the basic structure:\npackage main import ( \"os\" \"fmt\" \"net/http\" \"io/ioutil\" ) type Task struct { Id int `json:\"id\"` State int `json:\"state\"` } var databaseLocation string var storageLocation string func main() { if !registerInKVStore() { return } http.HandleFunc(\"/new\", newImage) http.HandleFunc(\"/get\", getImage) http.HandleFunc(\"/isReady\", isReady) http.HandleFunc(\"/getNewTask\", getNewTask) http.HandleFunc(\"/registerTaskFinished\", registerTaskFinished) http.ListenAndServe(\":3003\", nil) } func newImage(w http.ResponseWriter, r *http.Request) { } func getImage(w http.ResponseWriter, r *http.Request) { } func isReady(w http.ResponseWriter, r *http.Request) { } func getNewTask(w http.ResponseWriter, r *http.Request) { } func registerTaskFinished(w http.ResponseWriter, r *http.Request) { } func registerInKVStore() bool { if len(os.Args) \u003c 3 { fmt.Println(\"Error: Too few arguments.\") return false } masterAddress := os.Args[1] // The address of itself keyValueStoreAddress := os.Args[2] response, err := http.Post(\"http://\" + keyValueStoreAddress + \"/set?key=masterAddress\u0026value=\" + masterAddress, \"\", nil) if err != nil { fmt.Println(err) return false } data, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(err) return false } if response.StatusCode != http.StatusOK { fmt.Println(\"Error: Failure when contacting key-value store: \", string(data)) return false } return true } It’s the structure of the API and the mechanics to register in the k/v store.\nWe also need to get the storage and database locations in the main function:\nif !registerInKVStore() { return } keyValueStoreAddress = os.Args[2] response, err := http.Get(\"http://\" + keyValueStoreAddress + \"/get?key=databaseAddress\") if response.StatusCode != http.StatusOK { fmt.Println(\"Error: can't get database address.\") fmt.Println(response.Body) return } data, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(err) return } databaseLocation = string(data) response, err = http.Get(\"http://\" + keyValueStoreAddress + \"/get?key=storageAddress\") if response.StatusCode != http.StatusOK { fmt.Println(\"Error: can't get storage address.\") fmt.Println(response.Body) return } data, err = ioutil.ReadAll(response.Body) if err != nil { fmt.Println(err) return } storageLocation = string(data) Now we can start implementing all the functionality!\nLet’s start with the newImage function as it contains a good bit of code and mechanics which will be again used in the other funtions.\nHere’s the beginning:\nfunc newImage(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { response, err := http.Post(\"http://\" + databaseLocation + \"/newTask\", \"text/plain\", nil) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } id, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(err) return } } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } As usual we check if the method is right. Next we register a new Task in the database and get and Id.\nWe now use this to send the image to the storage:\nid, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(err) return } _, err = http.Post(\"http://\" + storageLocation + \"/sendImage?id=\" + string(id) + \"\u0026state=working\", \"image\", r.Body) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } fmt.Fprint(w, string(id)) That’s it. The new task will be created, the storage will get a file into the working directory with the name of the file being the id, and the client gets back the id. The important thing here is that we need the raw image in the request. The user form has to be parsed in the frontend service.\nNow we can create the function which just checks if a Task is ready:\nfunc isReady(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodGet { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { fmt.Fprint(w, err) return } if len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Wrong input\") return } } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only GET accepted\") } } We first have to verify all the parameters and the request method. Next we can ask the database for the Task requested:\nif len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Wrong input\") return } response, err := http.Get(\"http://\" + databaseLocation + \"/getById?id=\" + values.Get(\"id\")) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } data, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(err) return } We also read the response immediately. Now we can parse the Task and respond to the client:\nif err != nil { fmt.Println(err) return } myTask := Task{} json.Unmarshal(data, \u0026myTask) if(myTask.State == 2) { fmt.Fprint(w, \"1\") } else { fmt.Fprint(w, \"0\") } So now we can implement the last client facing interface, the getImage function:\nif r.Method == http.MethodGet { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { fmt.Fprint(w, err) return } if len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Wrong input\") return } } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only GET accepted\") } Here we verified the request and now we need to get the image from the storage system, and just copy the response to our client:\nif len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Wrong input\") return } response, err := http.Get(\"http://\" + storageLocation + \"/getImage?id=\" + values.Get(\"id\") + \"\u0026state=finished\") if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } _, err = io.Copy(w, response.Body) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } That’s it! The client facing interface is finished!\nImplementing the worker facing interface Now we have to implement the functions to serve the workers.\nBoth functions will basically be just direct routes to the database and back, so now let’s write ’em too:\nfunc getNewTask(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { response, err := http.Post(\"http://\" + databaseLocation + \"/getNewTask\", \"text/plain\", nil) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } _, err = io.Copy(w, response.Body) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } func registerTaskFinished(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { fmt.Fprint(w, err) return } if len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Wrong input\") return } response, err := http.Post(\"http://\" + databaseLocation + \"/finishTask?id=\" + values.Get(\"id\"), \"test/plain\", nil) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } _, err = io.Copy(w, response.Body) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } There’s not much to explain. They are both just passing further the request and responding with what they get.\nYou could think the workers should communicate directly with the database to get new Tasks. And with the current implementation it would work perfectly. However, if we wanted to add some functionality the master wanted to do for each of those requests it would be hard to implement. So this way is very extensible, and that’s nearly always what we want.\nConclusion Now we have finished the Master and the Storage system. We now have the dependencies to create the workers and frontend which we will implement in the next part. As always I encourage you to comment about your opinion. Have fun extending the system to do what you want to achieve!\nNext part\n","wordCount":"1847","inLanguage":"en","datePublished":"2016-03-21T13:25:39Z","dateModified":"2016-03-21T13:25:39Z","author":{"@type":"Person","name":"Jacob Martin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kubamartin.com/2016/03/21/web-app-using-microservices-in-go-part-3-storage-and-master/"},"publisher":{"@type":"Organization","name":"Jacob Martin","logo":{"@type":"ImageObject","url":"https://kubamartin.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kubamartin.com/ accesskey=h title="Jacob Martin (Alt + H)">Jacob Martin</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kubamartin.com/ title="About Me"><span>About Me</span></a></li><li><a href=https://kubamartin.com/archive title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kubamartin.com/>Home</a>&nbsp;»&nbsp;<a href=https://kubamartin.com/posts/>Posts</a></div><h1 class=post-title>Web app using Microservices in Go: Part 3 – Storage and Master</h1><div class=post-meta><span title='2016-03-21 13:25:39 +0000 UTC'>March 21, 2016</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Jacob Martin&nbsp;|&nbsp;<a href=https://github.com/cube2222/cube2222.github.io/content/posts/2016-03-21-web-app-using-microservices-in-go-part-3-storage-and-master.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><a href=https://kubamartin.com/2016/03/16/web-app-using-microservices-in-go-part-2-kv-store-and-database/>Previous part</a></p><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In this part we will implement the next part of the microservices needed for our web app. We will implement the:</p><ul><li>Storage system</li><li>Master</li></ul><p>This way we will have the <em>Master API</em> ready when we’ll be writing the slaves/workers and the frontend. And we’ll already have the database, k/v store and storage when writing the master. SO every time we write something we’ll already have all its dependencies.</p><h2 id=the-storage-system>The storage system<a hidden class=anchor aria-hidden=true href=#the-storage-system>#</a></h2><p>Ok, this one will be pretty easy to write. Just handling files. Let’s build the basic structure, which will include a function to register in our k/v store. For reference how it works check out the <a href=https://kubamartin.com/2016/03/16/web-app-using-microservices-in-go-part-2-kv-store-and-database/>previous part</a>. So here’s the basic structure:</p><pre tabindex=0><code>package main

import (
    &#34;fmt&#34;
    &#34;net/http&#34;
    &#34;io/ioutil&#34;
    &#34;os&#34;
    &#34;net/url&#34;
    &#34;io&#34;
)

func main() {
    if !registerInKVStore() {
        return
    }
    http.HandleFunc(&#34;/sendImage&#34;, receiveImage)
    http.HandleFunc(&#34;/getImage&#34;, serveImage)
    http.ListenAndServe(&#34;:3002&#34;, nil)
}

func receiveImage(w http.ResponseWriter, r *http.Request) {
}

func serveImage(w http.ResponseWriter, r *http.Request) {
}

func registerInKVStore() bool {
    if len(os.Args) &lt; 3 {
        fmt.Println(&#34;Error: Too few arguments.&#34;)
        return false
    }
    storageAddress := os.Args[1] // The address of itself
    keyValueStoreAddress := os.Args[2]

    response, err := http.Post(&#34;http://&#34; + keyValueStoreAddress + &#34;/set?key=storageAddress&amp;value=&#34; + storageAddress, &#34;&#34;, nil)
    if err != nil {
        fmt.Println(err)
        return false
    }
    data, err := ioutil.ReadAll(response.Body)
    if err != nil {
        fmt.Println(err)
        return false
    }
    if response.StatusCode != http.StatusOK {
        fmt.Println(&#34;Error: Failure when contacting key-value store: &#34;, string(data))
        return false
    }
    return true
}
</code></pre><p>So now we’ll have to handle the file serving/uploading. We will use a state <em>url argument</em> to specify if we are using the not yet finished (aka <em>working</em>) directory, or the <em>finished</em> one.</p><p>So first let’s write the <strong><em>receiveImage</em></strong> function which is there to get the files from clients:</p><pre tabindex=0><code>func receiveImage(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        values, err := url.ParseQuery(r.URL.RawQuery)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }
        if len(values.Get(&#34;id&#34;)) == 0 {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;,&#34;Wrong input id.&#34;)
            return
        }
        if values.Get(&#34;state&#34;) != &#34;working&#34; &amp;&amp; values.Get(&#34;state&#34;) != &#34;finished&#34; {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;,&#34;Wrong input state.&#34;)
            return
        }
    } else {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprint(w, &#34;Error: Only POST accepted&#34;)
    }
}
</code></pre><p>Here we check if the request method is <strong>POST</strong>, if there is an <em>id</em>, and if the state is <em>working</em> or <em>finished</em>.</p><p>Next we can create the file and put in the image:</p><pre tabindex=0><code>if values.Get(&#34;state&#34;) != &#34;working&#34; &amp;&amp; values.Get(&#34;state&#34;) != &#34;finished&#34; {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;,&#34;Wrong input state.&#34;)
            return
        }

        _, err = strconv.Atoi(values.Get(&#34;id&#34;))
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;,&#34;Wrong input id.&#34;)
            return
        }

        file, err := os.Create(&#34;/tmp/&#34; + values.Get(&#34;state&#34;) + &#34;/&#34; + values.Get(&#34;id&#34;) + &#34;.png&#34;)
        defer file.Close()
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }

        _, err = io.Copy(file, r.Body)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }

        fmt.Fprint(w, &#34;success&#34;)
</code></pre><p>We create a file in the tmp/<em>state</em> directory with the right <em>id</em>. Another thing we do is check if the <em>id</em> really is a valid int. We parse it to an int, to see if it succeeds and if it does then we use it, as a string.</p><p>we use the <em>io.Copy</em> function to put all the data from the <em>request</em> to the file. That means that the <em>body</em> of our request should be a raw image.</p><p>Next we can write the function to serve images which is pretty similar:</p><pre tabindex=0><code>func serveImage(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodGet {
        values, err := url.ParseQuery(r.URL.RawQuery)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }
        if len(values.Get(&#34;id&#34;)) == 0 {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;,&#34;Wrong input id.&#34;)
            return
        }
        if values.Get(&#34;state&#34;) != &#34;working&#34; &amp;&amp; values.Get(&#34;state&#34;) != &#34;finished&#34; {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;,&#34;Wrong input state.&#34;)
            return
        }

        _, err = strconv.Atoi(values.Get(&#34;id&#34;))
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;,&#34;Wrong input id.&#34;)
            return
        }

        file, err := os.Open(&#34;/tmp/&#34; + values.Get(&#34;state&#34;) + &#34;/&#34; + values.Get(&#34;id&#34;) + &#34;.png&#34;)
        defer file.Close()
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }

        _, err = io.Copy(w, file)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }
    } else {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprint(w, &#34;Error: Only GET accepted&#34;)
    }
}
</code></pre><p>Instead of creating the file, we open it. Instead of copying to the file we copy from it. And we check if the method is <strong>GET</strong>.</p><p>That’s it. We’ve got a storage service which saves and servers raw image files. Now we can get to the master!</p><h2 id=the-master>The master<a hidden class=anchor aria-hidden=true href=#the-master>#</a></h2><p>We now have all the dependencies the master needs. So let’s write it now. Here’s the basic structure:</p><pre tabindex=0><code>package main

import (
    &#34;os&#34;
    &#34;fmt&#34;
    &#34;net/http&#34;
    &#34;io/ioutil&#34;
)

type Task struct {
    Id int `json:&#34;id&#34;`
    State int `json:&#34;state&#34;`
}

var databaseLocation string
var storageLocation string

func main() {
    if !registerInKVStore() {
        return
    }

    http.HandleFunc(&#34;/new&#34;, newImage)
    http.HandleFunc(&#34;/get&#34;, getImage)
    http.HandleFunc(&#34;/isReady&#34;, isReady)
    http.HandleFunc(&#34;/getNewTask&#34;, getNewTask)
    http.HandleFunc(&#34;/registerTaskFinished&#34;, registerTaskFinished)
    http.ListenAndServe(&#34;:3003&#34;, nil)
}

func newImage(w http.ResponseWriter, r *http.Request) {
}

func getImage(w http.ResponseWriter, r *http.Request) {
}

func isReady(w http.ResponseWriter, r *http.Request) {
}

func getNewTask(w http.ResponseWriter, r *http.Request) {
}

func registerTaskFinished(w http.ResponseWriter, r *http.Request) {
}

func registerInKVStore() bool {
    if len(os.Args) &lt; 3 {
        fmt.Println(&#34;Error: Too few arguments.&#34;)
        return false
    }
    masterAddress := os.Args[1] // The address of itself
    keyValueStoreAddress := os.Args[2]

    response, err := http.Post(&#34;http://&#34; + keyValueStoreAddress + &#34;/set?key=masterAddress&amp;value=&#34; + masterAddress, &#34;&#34;, nil)
    if err != nil {
        fmt.Println(err)
        return false
    }
    data, err := ioutil.ReadAll(response.Body)
    if err != nil {
        fmt.Println(err)
        return false
    }
    if response.StatusCode != http.StatusOK {
        fmt.Println(&#34;Error: Failure when contacting key-value store: &#34;, string(data))
        return false
    }
    return true
}
</code></pre><p>It’s the structure of the <strong>API</strong> and the mechanics to register in the <em>k/v store</em>.</p><p>We also need to get the storage and database locations in the main function:</p><pre tabindex=0><code>if !registerInKVStore() {
        return
    }
    keyValueStoreAddress = os.Args[2]

    response, err := http.Get(&#34;http://&#34; + keyValueStoreAddress + &#34;/get?key=databaseAddress&#34;)
    if response.StatusCode != http.StatusOK {
        fmt.Println(&#34;Error: can&#39;t get database address.&#34;)
        fmt.Println(response.Body)
        return
    }
    data, err := ioutil.ReadAll(response.Body)
    if err != nil {
        fmt.Println(err)
        return
    }
    databaseLocation = string(data)

    response, err = http.Get(&#34;http://&#34; + keyValueStoreAddress + &#34;/get?key=storageAddress&#34;)
    if response.StatusCode != http.StatusOK {
        fmt.Println(&#34;Error: can&#39;t get storage address.&#34;)
        fmt.Println(response.Body)
        return
    }
    data, err = ioutil.ReadAll(response.Body)
    if err != nil {
        fmt.Println(err)
        return
    }
    storageLocation = string(data)
</code></pre><p>Now we can start implementing all the functionality!</p><p>Let’s start with the <em>newImage</em> function as it contains a good bit of code and mechanics which will be again used in the other funtions.<br>Here’s the beginning:</p><pre tabindex=0><code>func newImage(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        response, err := http.Post(&#34;http://&#34; + databaseLocation + &#34;/newTask&#34;, &#34;text/plain&#34;, nil)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }
        id, err := ioutil.ReadAll(response.Body)
        if err != nil {
            fmt.Println(err)
            return
        }
    } else {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprint(w, &#34;Error: Only POST accepted&#34;)
    }
}
</code></pre><p>As usual we check if the method is right. Next we register a new <em>Task</em> in the database and get and <em>Id</em>.</p><p>We now use this to send the image to the storage:</p><pre tabindex=0><code>id, err := ioutil.ReadAll(response.Body)
if err != nil {
    fmt.Println(err)
    return
}

_, err = http.Post(&#34;http://&#34; + storageLocation + &#34;/sendImage?id=&#34; + string(id) + &#34;&amp;state=working&#34;, &#34;image&#34;, r.Body)
if err != nil {
    w.WriteHeader(http.StatusBadRequest)
    fmt.Fprint(w, &#34;Error:&#34;, err)
    return
}
fmt.Fprint(w, string(id))
</code></pre><p>That’s it. The new task will be created, the storage will get a file into the working directory with the name of the file being the <em>id</em>, and the client gets back the <em>id</em>. The important thing here is that we need the raw image in the request. The user form has to be parsed in the frontend service.</p><p>Now we can create the function which just checks if a <em>Task</em> is ready:</p><pre tabindex=0><code>func isReady(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodGet {
        values, err := url.ParseQuery(r.URL.RawQuery)
        if err != nil {
            fmt.Fprint(w, err)
            return
        }
        if len(values.Get(&#34;id&#34;)) == 0 {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Wrong input&#34;)
            return
        }
    } else {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprint(w, &#34;Error: Only GET accepted&#34;)
    }
}
</code></pre><p>We first have to verify all the parameters and the request method. Next we can ask the database for the <em>Task</em> requested:</p><pre tabindex=0><code>if len(values.Get(&#34;id&#34;)) == 0 {
    w.WriteHeader(http.StatusBadRequest)
    fmt.Fprint(w, &#34;Wrong input&#34;)
    return
}

response, err := http.Get(&#34;http://&#34; + databaseLocation + &#34;/getById?id=&#34; + values.Get(&#34;id&#34;))
if err != nil {
    w.WriteHeader(http.StatusBadRequest)
    fmt.Fprint(w, &#34;Error:&#34;, err)
    return
}
data, err := ioutil.ReadAll(response.Body)
if err != nil {
    fmt.Println(err)
    return
}
</code></pre><p>We also read the response immediately. Now we can parse the <em>Task</em> and respond to the client:</p><pre tabindex=0><code>if err != nil {
    fmt.Println(err)
    return
}

myTask := Task{}
json.Unmarshal(data, &amp;myTask)

if(myTask.State == 2) {
    fmt.Fprint(w, &#34;1&#34;)
} else {
    fmt.Fprint(w, &#34;0&#34;)
}
</code></pre><p>So now we can implement the last client facing interface, the <em>getImage</em> function:</p><pre tabindex=0><code>if r.Method == http.MethodGet {
        values, err := url.ParseQuery(r.URL.RawQuery)
        if err != nil {
            fmt.Fprint(w, err)
            return
        }
        if len(values.Get(&#34;id&#34;)) == 0 {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Wrong input&#34;)
            return
        }
} else {
    w.WriteHeader(http.StatusBadRequest)
    fmt.Fprint(w, &#34;Error: Only GET accepted&#34;)
}
</code></pre><p>Here we verified the request and now we need to get the image from the storage system, and just copy the response to our client:</p><pre tabindex=0><code>if len(values.Get(&#34;id&#34;)) == 0 {
    w.WriteHeader(http.StatusBadRequest)
    fmt.Fprint(w, &#34;Wrong input&#34;)
    return
}

response, err := http.Get(&#34;http://&#34; + storageLocation + &#34;/getImage?id=&#34; + values.Get(&#34;id&#34;) + &#34;&amp;state=finished&#34;)
if err != nil {
    w.WriteHeader(http.StatusBadRequest)
    fmt.Fprint(w, &#34;Error:&#34;, err)
    return
}

_, err = io.Copy(w, response.Body)
if err != nil {
    w.WriteHeader(http.StatusBadRequest)
    fmt.Fprint(w, &#34;Error:&#34;, err)
    return
}
</code></pre><p>That’s it! The client facing interface is finished!</p><h3 id=implementing-the-worker-facing-interface>Implementing the worker facing interface<a hidden class=anchor aria-hidden=true href=#implementing-the-worker-facing-interface>#</a></h3><p>Now we have to implement the functions to serve the workers.</p><p>Both functions will basically be just direct routes to the database and back, so now let’s write ’em too:</p><pre tabindex=0><code>func getNewTask(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        response, err := http.Post(&#34;http://&#34; + databaseLocation + &#34;/getNewTask&#34;, &#34;text/plain&#34;, nil)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }

        _, err = io.Copy(w, response.Body)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }
    } else {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprint(w, &#34;Error: Only POST accepted&#34;)
    }
}

func registerTaskFinished(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        values, err := url.ParseQuery(r.URL.RawQuery)
        if err != nil {
            fmt.Fprint(w, err)
            return
        }
        if len(values.Get(&#34;id&#34;)) == 0 {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Wrong input&#34;)
            return
        }

        response, err := http.Post(&#34;http://&#34; + databaseLocation + &#34;/finishTask?id=&#34; + values.Get(&#34;id&#34;), &#34;test/plain&#34;, nil)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }

        _, err = io.Copy(w, response.Body)
        if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            fmt.Fprint(w, &#34;Error:&#34;, err)
            return
        }
    } else {
        w.WriteHeader(http.StatusBadRequest)
        fmt.Fprint(w, &#34;Error: Only POST accepted&#34;)
    }
}
</code></pre><p>There’s not much to explain. They are both just passing further the request and responding with what they get.</p><p>You could think the workers should communicate directly with the database to get new <em>Tasks</em>. And with the current implementation it would work perfectly. However, if we wanted to add some functionality the <em>master</em> wanted to do for each of those requests it would be hard to implement. So this way is very extensible, and that’s nearly always what we want.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Now we have finished the <em>Master</em> and the <em>Storage system</em>. We now have the dependencies to create the workers and frontend which we will implement in the next part. As always I encourage you to comment about your opinion. Have fun extending the system to do what you want to achieve!</p><p><a href=https://kubamartin.com/2016/03/23/web-app-using-microservices-in-go-part-4-worker-and-frontend/>Next part</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kubamartin.com/tags/architecture/>architecture</a></li><li><a href=https://kubamartin.com/tags/go/>go</a></li><li><a href=https://kubamartin.com/tags/golang/>golang</a></li><li><a href=https://kubamartin.com/tags/image/>image</a></li><li><a href=https://kubamartin.com/tags/master/>master</a></li><li><a href=https://kubamartin.com/tags/microservice/>microservice</a></li><li><a href=https://kubamartin.com/tags/storage/>storage</a></li><li><a href=https://kubamartin.com/tags/web-app/>web app</a></li><li><a href=https://kubamartin.com/tags/worker/>worker</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 3 – Storage and Master on twitter" href="https://twitter.com/intent/tweet/?text=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%203%20%e2%80%93%20Storage%20and%20Master&url=https%3a%2f%2fkubamartin.com%2f2016%2f03%2f21%2fweb-app-using-microservices-in-go-part-3-storage-and-master%2f&hashtags=architecture%2cgo%2cgolang%2cimage%2cmaster%2cmicroservice%2cstorage%2cwebapp%2cworker"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 3 – Storage and Master on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkubamartin.com%2f2016%2f03%2f21%2fweb-app-using-microservices-in-go-part-3-storage-and-master%2f&title=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%203%20%e2%80%93%20Storage%20and%20Master&summary=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%203%20%e2%80%93%20Storage%20and%20Master&source=https%3a%2f%2fkubamartin.com%2f2016%2f03%2f21%2fweb-app-using-microservices-in-go-part-3-storage-and-master%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 3 – Storage and Master on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkubamartin.com%2f2016%2f03%2f21%2fweb-app-using-microservices-in-go-part-3-storage-and-master%2f&title=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%203%20%e2%80%93%20Storage%20and%20Master"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 3 – Storage and Master on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkubamartin.com%2f2016%2f03%2f21%2fweb-app-using-microservices-in-go-part-3-storage-and-master%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 3 – Storage and Master on whatsapp" href="https://api.whatsapp.com/send?text=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%203%20%e2%80%93%20Storage%20and%20Master%20-%20https%3a%2f%2fkubamartin.com%2f2016%2f03%2f21%2fweb-app-using-microservices-in-go-part-3-storage-and-master%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 3 – Storage and Master on telegram" href="https://telegram.me/share/url?text=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%203%20%e2%80%93%20Storage%20and%20Master&url=https%3a%2f%2fkubamartin.com%2f2016%2f03%2f21%2fweb-app-using-microservices-in-go-part-3-storage-and-master%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://kubamartin.com/>Jacob Martin</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>