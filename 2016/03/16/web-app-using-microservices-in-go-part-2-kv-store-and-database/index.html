<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Web app using Microservices in Go: Part 2 – k/v store and Database | Jacob Martin</title><meta name=keywords content="architecture,database,go,golang,k/v store,key value store,microservice,web app"><meta name=description content="Previous part
Introduction In this part we will implement part of the microservices needed for our web app. We will implement the:
 key-value store Database  This will be a pretty code heavy tutorial so concentrate and have fun!
The key-value store Design The design hasn’t changed much. We will save the key-value pairs as a global map, and create a global mutex for concurrent access. We’ll also add the ability to list all key-value pairs for debugging/analytical purposes."><meta name=author content="Jacob Martin"><link rel=canonical href=https://jacobmartins.com/2016/03/16/web-app-using-microservices-in-go-part-2-kv-store-and-database/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://jacobmartins.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jacobmartins.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jacobmartins.com/favicon-32x32.png><link rel=apple-touch-icon href=https://jacobmartins.com/apple-touch-icon.png><link rel=mask-icon href=https://jacobmartins.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.85.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-74339391-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Web app using Microservices in Go: Part 2 – k/v store and Database"><meta property="og:description" content="Previous part
Introduction In this part we will implement part of the microservices needed for our web app. We will implement the:
 key-value store Database  This will be a pretty code heavy tutorial so concentrate and have fun!
The key-value store Design The design hasn’t changed much. We will save the key-value pairs as a global map, and create a global mutex for concurrent access. We’ll also add the ability to list all key-value pairs for debugging/analytical purposes."><meta property="og:type" content="article"><meta property="og:url" content="https://jacobmartins.com/2016/03/16/web-app-using-microservices-in-go-part-2-kv-store-and-database/"><meta property="og:image" content="https://jacobmartins.com/images/avatar.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-03-16T12:30:40+00:00"><meta property="article:modified_time" content="2016-03-16T12:30:40+00:00"><meta property="og:site_name" content="Jacob Martin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jacobmartins.com/images/avatar.jpg"><meta name=twitter:title content="Web app using Microservices in Go: Part 2 – k/v store and Database"><meta name=twitter:description content="Previous part
Introduction In this part we will implement part of the microservices needed for our web app. We will implement the:
 key-value store Database  This will be a pretty code heavy tutorial so concentrate and have fun!
The key-value store Design The design hasn’t changed much. We will save the key-value pairs as a global map, and create a global mutex for concurrent access. We’ll also add the ability to list all key-value pairs for debugging/analytical purposes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jacobmartins.com/posts/"},{"@type":"ListItem","position":2,"name":"Web app using Microservices in Go: Part 2 – k/v store and Database","item":"https://jacobmartins.com/2016/03/16/web-app-using-microservices-in-go-part-2-kv-store-and-database/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Web app using Microservices in Go: Part 2 – k/v store and Database","name":"Web app using Microservices in Go: Part 2 – k\/v store and Database","description":"Previous part\nIntroduction In this part we will implement part of the microservices needed for our web app. We will implement the:\n key-value store Database  This will be a pretty code heavy tutorial so concentrate and have fun!\nThe key-value store Design The design hasn’t changed much. We will save the key-value pairs as a global map, and create a global mutex for concurrent access. We’ll also add the ability to list all key-value pairs for debugging/analytical purposes.","keywords":["architecture","database","go","golang","k/v store","key value store","microservice","web app"],"articleBody":"Previous part\nIntroduction In this part we will implement part of the microservices needed for our web app. We will implement the:\n key-value store Database  This will be a pretty code heavy tutorial so concentrate and have fun!\nThe key-value store Design The design hasn’t changed much. We will save the key-value pairs as a global map, and create a global mutex for concurrent access. We’ll also add the ability to list all key-value pairs for debugging/analytical purposes. We will also add the ability to delete existing entries.\nFirst, let’s create the structure:\npackage main import ( \"net/http\" \"sync\" \"net/url\" \"fmt\" ) var keyValueStore map[string]string var kVStoreMutex sync.RWMutex func main() { keyValueStore = make(map[string]string) kVStoreMutex = sync.RWMutex{} http.HandleFunc(\"/get\", get) http.HandleFunc(\"/set\", set) http.HandleFunc(\"/remove\", remove) http.HandleFunc(\"/list\", list) http.ListenAndServe(\":3000\", nil) } func get(w http.ResponseWriter, r *http.Request) { } func set(w http.ResponseWriter, r *http.Request) { } func remove(w http.ResponseWriter, r *http.Request) { } func list(w http.ResponseWriter, r *http.Request) { } And now let’s dive into the implementation.\nFirst, we should add parameter parsing in the get function and verify that the key parameter is right.\nfunc get(w http.ResponseWriter, r *http.Request) { if(r.Method == http.MethodGet) { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } if len(values.Get(\"key\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input key.\") return } } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only GET accepted.\") } } The key shouldn’t have a length of 0, hence the length check. We also check if the method is GET, if it isn’t we print it and set the status code to bad request.\nWe answer with an explicit Error: before each error message so it doesn’t get misinterpreted by the client as a value.\nNow, let’s access our map and send back a response:\nif len(values.Get(\"key\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input key.\") return } kVStoreMutex.RLock() value := keyValueStore[string(values.Get(\"key\"))] kVStoreMutex.RUnlock() fmt.Fprint(w, value) We copy the value into a variable so that we don’t block the map while sending back the response.\nNow let’s create the set function, it’s actually pretty similar.\nfunc set(w http.ResponseWriter, r *http.Request) { if(r.Method == http.MethodPost) { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } if len(values.Get(\"key\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", \"Wrong input key.\") return } if len(values.Get(\"value\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", \"Wrong input value.\") return } kVStoreMutex.Lock() keyValueStore[string(values.Get(\"key\"))] = string(values.Get(\"value\")) kVStoreMutex.Unlock() fmt.Fprint(w, \"success\") } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted.\") } } The only difference is that we also check if there is a right value parameter and check if the method is POST.\nNow we can add the implementation of the list function which is also pretty simple:\nfunc list(w http.ResponseWriter, r *http.Request) { if(r.Method == http.MethodGet) { kVStoreMutex.RLock() for key, value := range keyValueStore { fmt.Fprintln(w, key, \":\", value) } kVStoreMutex.RUnlock() } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only GET accepted.\") } } It just ranges over the map and prints everything. Simple yet effective.\nAnd to finish the key-value store we will implement the remove function:\nfunc remove(w http.ResponseWriter, r *http.Request) { if(r.Method == http.MethodDelete) { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } if len(values.Get(\"key\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", \"Wrong input key.\") return } kVStoreMutex.Lock() delete(keyValueStore, values.Get(\"key\")) kVStoreMutex.Unlock() fmt.Fprint(w, \"success\") } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only DELETE accepted.\") } } It’s the same as setting a value, but instead of setting it we delete it.\nThe database Design After thinking through the design, I decided that it would be better if the database generated the task Id‘s. This will also make it easier to get the last non-finished task and generate consecutive Id‘s\nHow it will work:\n It will save new tasks assigning consecutive Id‘s. It will allow to get a new task to do. It will allow to get a task by Id. It will allow to set a task by Id. The state will be represented by an int: 0 – not started 1 – in progress 2 – finished It will change the state of a task to not started if it’s been too long in progress. (maybe someone started to work on it but has crashed) It will allow to list all tasks for debugging/analytical purposes.  Implementation First, we should create the API and later we will add the implementations of the functionality as before with the key-value store. We will also need a global map being our data store, a variable pointing to the oldest not started task, and mutexes for accessing the datastore and pointer.\npackage main import ( \"net/http\" \"net/url\" \"fmt\" ) type Task struct { } var datastore map[int]Task var datastoreMutex sync.RWMutex var oldestNotFinishedTask int // remember to account for potential int overflow in production. Use something bigger. var oNFTMutex sync.RWMutex func main() { datastore = make(map[int]Task) datastoreMutex = sync.RWMutex{} oldestNotFinishedTask = 0 oNFTMutex = sync.RWMutex{} http.HandleFunc(\"/getById\", getById) http.HandleFunc(\"/newTask\", newTask) http.HandleFunc(\"/getNewTask\", getNewTask) http.HandleFunc(\"/finishTask\", finishTask) http.HandleFunc(\"/setById\", setById) http.HandleFunc(\"/list\", list) http.ListenAndServe(\":3001\", nil) } func getById(w http.ResponseWriter, r *http.Request) { } func newTask(w http.ResponseWriter, r *http.Request) { } func getNewTask(w http.ResponseWriter, r *http.Request) { } func finishTask(w http.ResponseWriter, r *http.Request) { } func setById(w http.ResponseWriter, r *http.Request) { } func list(w http.ResponseWriter, r *http.Request) { } We also already declared the Task type which we will use for storage.\nSo far so good. Now let’s implement all those functions!\nFirst, let’s implement the getById function.\nfunc getById(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodGet { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { fmt.Fprint(w, err) return } if len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Wrong input\") return } id, err := strconv.Atoi(string(values.Get(\"id\"))) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, err) return } datastoreMutex.RLock() bIsInError := err != nil || id \u0026gt;= len(datastore) // Reading the length of a slice must be done in a synchronized manner. That's why the mutex is used.  datastoreMutex.RUnlock() if bIsInError { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Wrong input\") return } datastoreMutex.RLock() value := datastore[id] datastoreMutex.RUnlock() response, err := json.Marshal(value) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, err) return } fmt.Fprint(w, string(response)) } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only GET accepted\") } } We check if the GET method has been used. Later we parse the id argument and check if it’s proper. We then get the id as an int using the strconv.Atoi function. Next we make sure it is not out of bounds for our datastore, which we have to do using mutexes because we’re accessing a map which could be accessed from another thread. If everything is ok, then, again using mutexes, we get the task using the id.\nAfter that we use the JSON library to marshal our struct into a JSON object and if that finishes without problems we send the JSON object to the client.\nIt’s also time to implement our Task struct:\ntype Task struct { Id int `json:\"id\"` State int `json:\"state\"` } It’s all that’s needed. We also added the information the JSON marshaller needs.\nWe can now go on with implementing the newTask function:\nfunc newTask(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { datastoreMutex.Lock() taskToAdd := Task{ Id: len(datastore), State: 0, } datastore[taskToAdd.Id] = taskToAdd datastoreMutex.Unlock() fmt.Fprint(w, taskToAdd.Id) } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } It’s pretty small actually. Creating a new Task with the next id and adding it to the datastore. After that it sends back the new Tasks Id.\nThat means we can go on to implementing the function used to list all Tasks, as this helps with debugging during writing.\nIt’s basically the same as with the key-value store:\nfunc list(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodGet { datastoreMutex.RLock() for key, value := range datastore { fmt.Fprintln(w, key, \": \", \"id:\", value.Id, \" state:\", value.State) } datastoreMutex.RUnlock() } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only GET accepted\") } } Ok, so now we will implement the function which can set the Task by id:\nfunc setById(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { taskToSet := Task{} data, err := ioutil.ReadAll(r.Body) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, err) return } err = json.Unmarshal([]byte(data), \u0026taskToSet) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, err) return } bErrored := false datastoreMutex.Lock() if taskToSet.Id \u0026gt;= len(datastore) || taskToSet.State \u0026gt; 2 || taskToSet.State \u0026lt; 0 { bErrored = true } else { datastore[taskToSet.Id] = taskToSet } datastoreMutex.Unlock() if bErrored { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Wrong input\") return } fmt.Fprint(w, \"success\") } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } Nothing new. We get the request and try to unmarshal it. If it succeeds we put it into the map, checking if it isn’t out of bounds or if the state is invalid. If it is then we print an error, otherwise we print success.\nIf we already have this we can now implement the finish task function, because it’s very simple:\nfunc finishTask(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { fmt.Fprint(w, err) return } if len(values.Get(\"id\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Wrong input\") return } id, err := strconv.Atoi(string(values.Get(\"id\"))) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, err) return } updatedTask := Task{Id: id, State: 2} bErrored := false datastoreMutex.Lock() if datastore[id].State == 1 { datastore[id] = updatedTask } else { bErrored = true } datastoreMutex.Unlock() if bErrored { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Wrong input\") return } fmt.Fprint(w, \"success\") } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } It’s pretty similar to the getById function. The difference here is that here we update the state and only if it is currently in progress.\nAnd now to one of the most interesting functions. The getNewTask function. It has to handle updating the oldest known finished task, and it also needs to handle the situation when someone takes a task but crashes during work. This would lead to a ghost task forever being in progress. That’s why we’ll add functionality which after 120 seconds from starting a task will set it back to not started:\nfunc getNewTask(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { bErrored := false datastoreMutex.RLock() if len(datastore) == 0 { bErrored = true } datastoreMutex.RUnlock() if bErrored { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: No non-started task.\") return } taskToSend := Task{Id: -1, State: 0} oNFTMutex.Lock() datastoreMutex.Lock() for i := oldestNotFinishedTask; i \u0026lt; len(datastore); i++ { if datastore[i].State == 2 \u0026\u0026 i == oldestNotFinishedTask { oldestNotFinishedTask++ continue } if datastore[i].State == 0 { datastore[i] = Task{Id: i, State: 1} taskToSend = datastore[i] break } } datastoreMutex.Unlock() oNFTMutex.Unlock() if taskToSend.Id == -1 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: No non-started task.\") return } myId := taskToSend.Id go func() { time.Sleep(time.Second * 120) datastoreMutex.Lock() if datastore[myId].State == 1 { datastore[myId] = Task{Id: myId, State: 0} } datastoreMutex.Unlock() }() response, err := json.Marshal(taskToSend) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, err) return } fmt.Fprint(w, string(response)) } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } First we try to find the oldest task that hasn’t started yet. By the way we update the oldestNotFinishedTask variable. If a task is finished and is pointed on by the variable, the variable get’s incremented. If we find something that’s not started, then we break out of the loop and send it back to the user setting it to in progress. However, on the way we start a function on another thread that will change the state of the task back to not started if it’s still in progress after 120 seconds.\nNow the last thing. A database is useless… when you don’t know where it is! That’s why we’ll now implement the mechanism that the database will use to register itself in the key-value store:\nfunc main() { if !registerInKVStore() { return } datastore = make(map[int]Task) and later we define the function:\nfunc registerInKVStore() bool { if len(os.Args) \u0026lt; 3 { fmt.Println(\"Error: Too few arguments.\") return false } databaseAddress := os.Args[1] // The address of itself  keyValueStoreAddress := os.Args[2] response, err := http.Post(\"http://\" + keyValueStoreAddress + \"/set?key=databaseAddress\u0026value=\" + databaseAddress, \"\", nil) if err != nil { fmt.Println(err) return false } data, err := ioutil.ReadAll(response.Body) if err != nil { fmt.Println(err) return false } if response.StatusCode != http.StatusOK { fmt.Println(\"Error: Failure when contacting key-value store: \", string(data)) return false } return true } We check if there are at least 3 arguments. (The first being the executable) We read the current database address from the second argument and the key-value store address from the third argument. We use them to make a POST request where we add a databaseAddress key to the k/v store and set its value to the current database address. If the status code of the response isn’t OK then we know we messed up and we print the error we got. After that we quit the program.\nConclusion We now have finished our k/v store and our database. You can even test them now using a REST client. (I used this one.) Remember that the code is subject to change if it will be necessary but I don’t think so. I hope you enjoyed the tutorial! I encourage you to comment, and if you have an opposing view to mine please make sure to express it in a comment too!\nUPDATE: I changed the sync.Mutex to sync.RWMutex, and in the places where we only read data I changed mutex.Lock/Unlock to mutex.RLock/RUnlock.\nUPDATE2: For some reason I used a slice for the database code although I tested with a map. Sorry for that, corrected it already.\nNext part\n","wordCount":"2252","inLanguage":"en","datePublished":"2016-03-16T12:30:40Z","dateModified":"2016-03-16T12:30:40Z","author":{"@type":"Person","name":"Jacob Martin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jacobmartins.com/2016/03/16/web-app-using-microservices-in-go-part-2-kv-store-and-database/"},"publisher":{"@type":"Organization","name":"Jacob Martin","logo":{"@type":"ImageObject","url":"https://jacobmartins.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://jacobmartins.com/ accesskey=h title="Jacob Martin (Alt + H)">Jacob Martin</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://jacobmartins.com/ title="About Me"><span>About Me</span></a></li><li><a href=https://jacobmartins.com/archive title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jacobmartins.com/>Home</a>&nbsp;»&nbsp;<a href=https://jacobmartins.com/posts/>Posts</a></div><h1 class=post-title>Web app using Microservices in Go: Part 2 – k/v store and Database</h1><div class=post-meta>March 16, 2016&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Jacob Martin&nbsp;|&nbsp;<a href=https://github.com/cube2222/cube2222.github.io/content/posts/2016-03-16-web-app-using-microservices-in-go-part-2-kv-store-and-database.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><a href=https://jacobmartins.com/2016/03/14/web-app-using-microservices-in-go-part-1-design/>Previous part</a></p><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In this part we will implement part of the microservices needed for our web app. We will implement the:</p><ul><li>key-value store</li><li>Database</li></ul><p>This will be a pretty code heavy tutorial so concentrate and have fun!</p><h2 id=the-key-value-store>The key-value store<a hidden class=anchor aria-hidden=true href=#the-key-value-store>#</a></h2><h3 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h3><p>The design hasn’t changed much. We will save the key-value pairs as a global map, and create a global mutex for concurrent access. We’ll also add the ability to list all key-value pairs for debugging/analytical purposes. We will also add the ability to delete existing entries.</p><p>First, let’s create the structure:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
    <span style=color:#e6db74>&#34;net/http&#34;</span>
    <span style=color:#e6db74>&#34;sync&#34;</span>
    <span style=color:#e6db74>&#34;net/url&#34;</span>
    <span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>keyValueStore</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>kVStoreMutex</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#a6e22e>keyValueStore</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)
    <span style=color:#a6e22e>kVStoreMutex</span> = <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>{}
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/get&#34;</span>, <span style=color:#a6e22e>get</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/set&#34;</span>, <span style=color:#a6e22e>set</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/remove&#34;</span>, <span style=color:#a6e22e>remove</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/list&#34;</span>, <span style=color:#a6e22e>list</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:3000&#34;</span>, <span style=color:#66d9ef>nil</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>remove</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>list</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

</code></pre></div><p>And now let’s dive into the implementation.</p><p>First, we should add parameter parsing in the get function and verify that the key parameter is right.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>get</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodGet</span>) {
        <span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>ParseQuery</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>RawQuery</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }
        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;key&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>,<span style=color:#e6db74>&#34;Wrong input key.&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only GET accepted.&#34;</span>)
    }
}
</code></pre></div><p>The <em>key</em> shouldn’t have a length of 0, hence the length check. We also check if the method is GET, if it isn’t we print it and set the status code to <strong><em>bad request</em></strong>.<br>We answer with an explicit <strong><em>Error:</em></strong> before each error message so it doesn’t get misinterpreted by the client as a value.</p><p>Now, let’s access our map and send back a response:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;key&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>,<span style=color:#e6db74>&#34;Wrong input key.&#34;</span>)
    <span style=color:#66d9ef>return</span>
}

<span style=color:#a6e22e>kVStoreMutex</span>.<span style=color:#a6e22e>RLock</span>()
<span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>keyValueStore</span>[string(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;key&#34;</span>))]
<span style=color:#a6e22e>kVStoreMutex</span>.<span style=color:#a6e22e>RUnlock</span>()

<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>value</span>)
</code></pre></div><p>We copy the value into a variable so that we don’t block the map while sending back the response.</p><p>Now let’s create the set function, it’s actually pretty similar.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span>) {
        <span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>ParseQuery</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>RawQuery</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }
        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;key&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>, <span style=color:#e6db74>&#34;Wrong input key.&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }
        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;value&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>, <span style=color:#e6db74>&#34;Wrong input value.&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>kVStoreMutex</span>.<span style=color:#a6e22e>Lock</span>()
        <span style=color:#a6e22e>keyValueStore</span>[string(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;key&#34;</span>))] = string(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;value&#34;</span>))
        <span style=color:#a6e22e>kVStoreMutex</span>.<span style=color:#a6e22e>Unlock</span>()

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;success&#34;</span>)
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only POST accepted.&#34;</span>)
    }
}
</code></pre></div><p>The only difference is that we also check if there is a right value parameter and check if the method is POST.</p><p>Now we can add the implementation of the list function which is also pretty simple:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>list</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodGet</span>) {
        <span style=color:#a6e22e>kVStoreMutex</span>.<span style=color:#a6e22e>RLock</span>()
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>keyValueStore</span> {
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintln</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>key</span>, <span style=color:#e6db74>&#34;:&#34;</span>, <span style=color:#a6e22e>value</span>)
        }
        <span style=color:#a6e22e>kVStoreMutex</span>.<span style=color:#a6e22e>RUnlock</span>()
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only GET accepted.&#34;</span>)
    }
}
</code></pre></div><p>It just ranges over the map and prints everything. Simple yet effective.</p><p>And to finish the key-value store we will implement the <em>remove</em> function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>remove</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodDelete</span>) {
        <span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>ParseQuery</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>RawQuery</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }
        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;key&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>, <span style=color:#e6db74>&#34;Wrong input key.&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>kVStoreMutex</span>.<span style=color:#a6e22e>Lock</span>()
        delete(<span style=color:#a6e22e>keyValueStore</span>, <span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;key&#34;</span>))
        <span style=color:#a6e22e>kVStoreMutex</span>.<span style=color:#a6e22e>Unlock</span>()

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;success&#34;</span>)
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only DELETE accepted.&#34;</span>)
    }
}
</code></pre></div><p>It’s the same as setting a value, but instead of setting it we delete it.</p><h2 id=the-database>The database<a hidden class=anchor aria-hidden=true href=#the-database>#</a></h2><h3 id=design-1>Design<a hidden class=anchor aria-hidden=true href=#design-1>#</a></h3><p>After thinking through the design, I decided that it would be better if the database generated the task <em>Id</em>‘s. This will also make it easier to get the last non-finished task and generate consecutive <em>Id</em>‘s</p><p>How it will work:</p><ul><li>It will save new tasks assigning consecutive <em>Id</em>‘s.</li><li>It will allow to get a new task to do.</li><li>It will allow to get a task by <em>Id</em>.</li><li>It will allow to set a task by <em>Id</em>.</li><li>The state will be represented by an int:</li><li>0 – not started</li><li>1 – in progress</li><li>2 – finished</li><li>It will change the state of a task to <em>not started</em> if it’s been too long <em>in progress</em>. (maybe someone started to work on it but has crashed)</li><li>It will allow to list all tasks for debugging/analytical purposes.</li></ul><p><img loading=lazy src=https://www.lucidchart.com/publicSegments/view/4cf0690e-3dbb-42d9-befd-4a6efaaf6f72/image.png alt="Database microservice post"></p><h3 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h3><p>First, we should create the API and later we will add the implementations of the functionality as before with the key-value store. We will also need a global map being our data store, a variable pointing to the oldest not started task, and mutexes for accessing the datastore and pointer.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
    <span style=color:#e6db74>&#34;net/http&#34;</span>
    <span style=color:#e6db74>&#34;net/url&#34;</span>
    <span style=color:#e6db74>&#34;fmt&#34;</span>
)

<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Task</span> <span style=color:#66d9ef>struct</span> {
}

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>datastore</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#a6e22e>Task</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>datastoreMutex</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>oldestNotFinishedTask</span> <span style=color:#66d9ef>int</span> <span style=color:#75715e>// remember to account for potential int overflow in production. Use something bigger.
</span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>oNFTMutex</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {

    <span style=color:#a6e22e>datastore</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#a6e22e>Task</span>)
    <span style=color:#a6e22e>datastoreMutex</span> = <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>{}
    <span style=color:#a6e22e>oldestNotFinishedTask</span> = <span style=color:#ae81ff>0</span>
    <span style=color:#a6e22e>oNFTMutex</span> = <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>{}

    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/getById&#34;</span>, <span style=color:#a6e22e>getById</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/newTask&#34;</span>, <span style=color:#a6e22e>newTask</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/getNewTask&#34;</span>, <span style=color:#a6e22e>getNewTask</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/finishTask&#34;</span>, <span style=color:#a6e22e>finishTask</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/setById&#34;</span>, <span style=color:#a6e22e>setById</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/list&#34;</span>, <span style=color:#a6e22e>list</span>)
    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:3001&#34;</span>, <span style=color:#66d9ef>nil</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getById</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newTask</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getNewTask</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>finishTask</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>setById</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>list</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
}
</code></pre></div><p>We also already declared the <strong><em>Task</em></strong> type which we will use for storage.</p><p>So far so good. Now let’s implement all those functions!</p><p>First, let’s implement the getById function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getById</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodGet</span> {
        <span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>ParseQuery</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>RawQuery</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }
        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;id&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Wrong input&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Atoi</span>(string(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;id&#34;</span>)))
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>RLock</span>()
        <span style=color:#a6e22e>bIsInError</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>id</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gt</span>;= len(<span style=color:#a6e22e>datastore</span>) <span style=color:#75715e>// Reading the length of a slice must be done in a synchronized manner. That&#39;s why the mutex is used.
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>RUnlock</span>()

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bIsInError</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Wrong input&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>RLock</span>()
        <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>id</span>]
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>RUnlock</span>()

        <span style=color:#a6e22e>response</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>value</span>)

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, string(<span style=color:#a6e22e>response</span>))
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only GET accepted&#34;</span>)
    }
}
</code></pre></div><p>We check if the <strong><em>GET</em></strong> method has been used. Later we parse the <em>id</em> argument and check if it’s proper. We then get the <em>id</em> as an <strong>int</strong> using the <em>strconv.Atoi</em> function. Next we make sure it is not out of bounds for our <em>datastore</em>, which we have to do using <em>mutexes</em> because we’re accessing a map which could be accessed from another thread. If everything is ok, then, again using <em>mutexes</em>, we get the task using the <em>id</em>.</p><p>After that we use the <em>JSON</em> library to marshal our struct into a <em>JSON object</em> and if that finishes without problems we send the <em>JSON object</em> to the client.</p><p>It’s also time to implement our <em>Task</em> struct:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Task</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>Id</span> <span style=color:#66d9ef>int</span> <span style=color:#e6db74>`json:&#34;id&#34;`</span>
    <span style=color:#a6e22e>State</span> <span style=color:#66d9ef>int</span> <span style=color:#e6db74>`json:&#34;state&#34;`</span>
}
</code></pre></div><p>It’s all that’s needed. We also added the information the <em>JSON</em> marshaller needs.</p><p>We can now go on with implementing the <em>newTask</em> function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newTask</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span> {
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Lock</span>()
        <span style=color:#a6e22e>taskToAdd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Task</span>{
            <span style=color:#a6e22e>Id</span>: len(<span style=color:#a6e22e>datastore</span>),
            <span style=color:#a6e22e>State</span>: <span style=color:#ae81ff>0</span>,
        }
        <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>taskToAdd</span>.<span style=color:#a6e22e>Id</span>] = <span style=color:#a6e22e>taskToAdd</span>
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Unlock</span>()

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>taskToAdd</span>.<span style=color:#a6e22e>Id</span>)
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only POST accepted&#34;</span>)
    }
}
</code></pre></div><p>It’s pretty small actually. Creating a new <em>Task</em> with the next id and adding it to the <em>datastore</em>. After that it sends back the new <em>Tasks</em> Id.</p><p>That means we can go on to implementing the function used to list all <em>Tasks</em>, as this helps with debugging during writing.</p><p>It’s basically the same as with the key-value store:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>list</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodGet</span> {
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>RLock</span>()
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>datastore</span> {
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintln</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>key</span>, <span style=color:#e6db74>&#34;: &#34;</span>, <span style=color:#e6db74>&#34;id:&#34;</span>, <span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>Id</span>, <span style=color:#e6db74>&#34; state:&#34;</span>, <span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>State</span>)
        }
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>RUnlock</span>()
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only GET accepted&#34;</span>)
    }
}
</code></pre></div><p>Ok, so now we will implement the function which can set the <em>Task</em> by <em>id</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>setById</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span> {
        <span style=color:#a6e22e>taskToSet</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Task</span>{}

        <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Body</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }
        <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>([]byte(<span style=color:#a6e22e>data</span>), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>taskToSet</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>bErrored</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Lock</span>()
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>taskToSet</span>.<span style=color:#a6e22e>Id</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gt</span>;= len(<span style=color:#a6e22e>datastore</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>taskToSet</span>.<span style=color:#a6e22e>State</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gt</span>; <span style=color:#ae81ff>2</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>taskToSet</span>.<span style=color:#a6e22e>State</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>lt</span>; <span style=color:#ae81ff>0</span> {
            <span style=color:#a6e22e>bErrored</span> = <span style=color:#66d9ef>true</span>
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>taskToSet</span>.<span style=color:#a6e22e>Id</span>] = <span style=color:#a6e22e>taskToSet</span>
        }
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Unlock</span>()

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bErrored</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Wrong input&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;success&#34;</span>)
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only POST accepted&#34;</span>)
    }
}
</code></pre></div><p>Nothing new. We get the request and try to unmarshal it. If it succeeds we put it into the map, checking if it isn’t out of bounds or if the state is invalid. If it is then we print an error, otherwise we print <em>success</em>.</p><p>If we already have this we can now implement the finish task function, because it’s very simple:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>finishTask</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span> {
        <span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>ParseQuery</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>RawQuery</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }
        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;id&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Wrong input&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Atoi</span>(string(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;id&#34;</span>)))

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>updatedTask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Task</span>{<span style=color:#a6e22e>Id</span>: <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>State</span>: <span style=color:#ae81ff>2</span>}

        <span style=color:#a6e22e>bErrored</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>

        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Lock</span>()
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>id</span>].<span style=color:#a6e22e>State</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
            <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>id</span>] = <span style=color:#a6e22e>updatedTask</span>
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#a6e22e>bErrored</span> = <span style=color:#66d9ef>true</span>
        }
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Unlock</span>()

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bErrored</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Wrong input&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;success&#34;</span>)
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only POST accepted&#34;</span>)
    }
}
</code></pre></div><p>It’s pretty similar to the <em>getById</em> function. The difference here is that here we update the state and only if it is currently <em>in progress</em>.</p><p>And now to one of the most interesting functions. The <em>getNewTask</em> function. It has to handle updating the oldest known finished task, and it also needs to handle the situation when someone takes a task but crashes during work. This would lead to a ghost task forever being <em>in progress</em>. That’s why we’ll add functionality which after 120 seconds from starting a task will set it back to <em>not started</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getNewTask</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span> {

        <span style=color:#a6e22e>bErrored</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>

        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>RLock</span>()
        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>datastore</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
            <span style=color:#a6e22e>bErrored</span> = <span style=color:#66d9ef>true</span>
        }
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>RUnlock</span>()

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>bErrored</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: No non-started task.&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>taskToSend</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Task</span>{<span style=color:#a6e22e>Id</span>: <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>State</span>: <span style=color:#ae81ff>0</span>}

        <span style=color:#a6e22e>oNFTMutex</span>.<span style=color:#a6e22e>Lock</span>()
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Lock</span>()
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>oldestNotFinishedTask</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>lt</span>; len(<span style=color:#a6e22e>datastore</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>State</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>oldestNotFinishedTask</span> {
                <span style=color:#a6e22e>oldestNotFinishedTask</span><span style=color:#f92672>++</span>
                <span style=color:#66d9ef>continue</span>
            }
            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>State</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
                <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>Task</span>{<span style=color:#a6e22e>Id</span>: <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>State</span>: <span style=color:#ae81ff>1</span>}
                <span style=color:#a6e22e>taskToSend</span> = <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>i</span>]
                <span style=color:#66d9ef>break</span>
            }
        }
        <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Unlock</span>()
        <span style=color:#a6e22e>oNFTMutex</span>.<span style=color:#a6e22e>Unlock</span>()

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>taskToSend</span>.<span style=color:#a6e22e>Id</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: No non-started task.&#34;</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>myId</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>taskToSend</span>.<span style=color:#a6e22e>Id</span>

        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
            <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>120</span>)
            <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Lock</span>()
            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>myId</span>].<span style=color:#a6e22e>State</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
                <span style=color:#a6e22e>datastore</span>[<span style=color:#a6e22e>myId</span>] = <span style=color:#a6e22e>Task</span>{<span style=color:#a6e22e>Id</span>: <span style=color:#a6e22e>myId</span>, <span style=color:#a6e22e>State</span>: <span style=color:#ae81ff>0</span>}
            }
            <span style=color:#a6e22e>datastoreMutex</span>.<span style=color:#a6e22e>Unlock</span>()
        }()

        <span style=color:#a6e22e>response</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>taskToSend</span>)

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>)
            <span style=color:#66d9ef>return</span>
        }

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, string(<span style=color:#a6e22e>response</span>))
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only POST accepted&#34;</span>)
    }
}
</code></pre></div><p>First we try to find the oldest task that hasn’t started yet. By the way we update the oldestNotFinishedTask variable. If a task is finished and is pointed on by the variable, the variable get’s incremented. If we find something that’s not started, then we break out of the loop and send it back to the user setting it to <em>in progress</em>. However, on the way we start a function on another thread that will change the state of the task back to <em>not started</em> if it’s still in progress after 120 seconds.</p><p>Now the last thing. A database is useless… when you don’t know where it is! That’s why we’ll now implement the mechanism that the database will use to register itself in the <em>key-value store</em>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {

    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>registerInKVStore</span>() {
        <span style=color:#66d9ef>return</span>
    }

    <span style=color:#a6e22e>datastore</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#a6e22e>Task</span>)
</code></pre></div><p>and later we define the function:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>registerInKVStore</span>() <span style=color:#66d9ef>bool</span> {
    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>) <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>lt</span>; <span style=color:#ae81ff>3</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Error: Too few arguments.&#34;</span>)
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
    }
    <span style=color:#a6e22e>databaseAddress</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>] <span style=color:#75715e>// The address of itself
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>keyValueStoreAddress</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>2</span>]

    <span style=color:#a6e22e>response</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Post</span>(<span style=color:#e6db74>&#34;http://&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>keyValueStoreAddress</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/set?key=databaseAddress&amp;value=&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>databaseAddress</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#66d9ef>nil</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
    }
    <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>Body</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
    }
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>StatusCode</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusOK</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Error: Failure when contacting key-value store: &#34;</span>, string(<span style=color:#a6e22e>data</span>))
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
</code></pre></div><p>We check if there are at least 3 arguments. (The first being the executable) We read the current <em>database address</em> from the second argument and the <em>key-value store address</em> from the third argument. We use them to make a POST request where we add a <strong><em>databaseAddress</em></strong> key to the <em>k/v store</em> and set its value to the current <em>database address</em>. If the status code of the response isn’t <strong><em>OK</em></strong> then we know we messed up and we print the error we got. After that we quit the program.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>We now have finished our <em>k/v store</em> and our <em>database</em>. You can even test them now using a REST client. (I used <a href=https://chrome.google.com/webstore/detail/advanced-rest-client/hgmloofddffdnphfgcellkdfbfbjeloo>this one</a>.) Remember that the code is subject to change if it will be necessary but I don’t think so. I hope you enjoyed the tutorial! I encourage you to comment, and if you have an opposing view to mine please make sure to express it in a comment too!</p><p><strong><em>UPDATE</em></strong>: I changed the sync.Mutex to sync.RWMutex, and in the places where we only read data I changed mutex.Lock/Unlock to mutex.RLock/RUnlock.</p><p><strong><em>UPDATE2</em></strong>: For some reason I used a slice for the database code although I tested with a map. Sorry for that, corrected it already.</p><p><a href=https://jacobmartins.com/2016/03/21/web-app-using-microservices-in-go-part-3-storage-and-master/>Next part</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jacobmartins.com/tags/architecture/>architecture</a></li><li><a href=https://jacobmartins.com/tags/database/>database</a></li><li><a href=https://jacobmartins.com/tags/go/>go</a></li><li><a href=https://jacobmartins.com/tags/golang/>golang</a></li><li><a href=https://jacobmartins.com/tags/k/v-store/>k/v store</a></li><li><a href=https://jacobmartins.com/tags/key-value-store/>key value store</a></li><li><a href=https://jacobmartins.com/tags/microservice/>microservice</a></li><li><a href=https://jacobmartins.com/tags/web-app/>web app</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 2 – k/v store and Database on twitter" href="https://twitter.com/intent/tweet/?text=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%202%20%e2%80%93%20k%2fv%20store%20and%20Database&url=https%3a%2f%2fjacobmartins.com%2f2016%2f03%2f16%2fweb-app-using-microservices-in-go-part-2-kv-store-and-database%2f&hashtags=architecture%2cdatabase%2cgo%2cgolang%2ck%2fvstore%2ckeyvaluestore%2cmicroservice%2cwebapp"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 2 – k/v store and Database on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjacobmartins.com%2f2016%2f03%2f16%2fweb-app-using-microservices-in-go-part-2-kv-store-and-database%2f&title=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%202%20%e2%80%93%20k%2fv%20store%20and%20Database&summary=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%202%20%e2%80%93%20k%2fv%20store%20and%20Database&source=https%3a%2f%2fjacobmartins.com%2f2016%2f03%2f16%2fweb-app-using-microservices-in-go-part-2-kv-store-and-database%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 2 – k/v store and Database on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjacobmartins.com%2f2016%2f03%2f16%2fweb-app-using-microservices-in-go-part-2-kv-store-and-database%2f&title=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%202%20%e2%80%93%20k%2fv%20store%20and%20Database"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 2 – k/v store and Database on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjacobmartins.com%2f2016%2f03%2f16%2fweb-app-using-microservices-in-go-part-2-kv-store-and-database%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 2 – k/v store and Database on whatsapp" href="https://api.whatsapp.com/send?text=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%202%20%e2%80%93%20k%2fv%20store%20and%20Database%20-%20https%3a%2f%2fjacobmartins.com%2f2016%2f03%2f16%2fweb-app-using-microservices-in-go-part-2-kv-store-and-database%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Web app using Microservices in Go: Part 2 – k/v store and Database on telegram" href="https://telegram.me/share/url?text=Web%20app%20using%20Microservices%20in%20Go%3a%20Part%202%20%e2%80%93%20k%2fv%20store%20and%20Database&url=https%3a%2f%2fjacobmartins.com%2f2016%2f03%2f16%2fweb-app-using-microservices-in-go-part-2-kv-store-and-database%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://jacobmartins.com/>Jacob Martin</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>