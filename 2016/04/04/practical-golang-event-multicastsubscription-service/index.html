<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Practical Golang: Event multicast/subscription service | Jacob Martin</title><meta name=keywords content="architecture,event,go,golang,message,microservice,subscription"><meta name=description content="Introduction In our microservice architectures we always need a method for communicating between services. There are various ways to achieve this. Few of them are, but are not limited to: Remote Procedure Call, REST API’s, message BUSses. In this comprehensive tutorial we’ll write a service, which you can use to distribute messages/events across your system.
Design How will it work? It will accept registering subscribers (other microservices). Whenever it gets a message from a microservice, it will send it further to all subscribers, using a REST call to the other microservices /event URL."><meta name=author content="Jacob Martin"><link rel=canonical href=https://jacobmartins.com/2016/04/04/practical-golang-event-multicastsubscription-service/><link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jacobmartins.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jacobmartins.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jacobmartins.com/favicon-32x32.png><link rel=apple-touch-icon href=https://jacobmartins.com/apple-touch-icon.png><link rel=mask-icon href=https://jacobmartins.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-74339391-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Practical Golang: Event multicast/subscription service"><meta property="og:description" content="Introduction In our microservice architectures we always need a method for communicating between services. There are various ways to achieve this. Few of them are, but are not limited to: Remote Procedure Call, REST API’s, message BUSses. In this comprehensive tutorial we’ll write a service, which you can use to distribute messages/events across your system.
Design How will it work? It will accept registering subscribers (other microservices). Whenever it gets a message from a microservice, it will send it further to all subscribers, using a REST call to the other microservices /event URL."><meta property="og:type" content="article"><meta property="og:url" content="https://jacobmartins.com/2016/04/04/practical-golang-event-multicastsubscription-service/"><meta property="og:image" content="https://jacobmartins.com/images/avatar.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-04-04T10:30:24+00:00"><meta property="article:modified_time" content="2016-04-04T10:30:24+00:00"><meta property="og:site_name" content="Jacob Martin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jacobmartins.com/images/avatar.jpg"><meta name=twitter:title content="Practical Golang: Event multicast/subscription service"><meta name=twitter:description content="Introduction In our microservice architectures we always need a method for communicating between services. There are various ways to achieve this. Few of them are, but are not limited to: Remote Procedure Call, REST API’s, message BUSses. In this comprehensive tutorial we’ll write a service, which you can use to distribute messages/events across your system.
Design How will it work? It will accept registering subscribers (other microservices). Whenever it gets a message from a microservice, it will send it further to all subscribers, using a REST call to the other microservices /event URL."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jacobmartins.com/posts/"},{"@type":"ListItem","position":2,"name":"Practical Golang: Event multicast/subscription service","item":"https://jacobmartins.com/2016/04/04/practical-golang-event-multicastsubscription-service/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Practical Golang: Event multicast/subscription service","name":"Practical Golang: Event multicast\/subscription service","description":"Introduction In our microservice architectures we always need a method for communicating between services. There are various ways to achieve this. Few of them are, but are not limited to: Remote Procedure Call, REST API’s, message BUSses. In this comprehensive tutorial we’ll write a service, which you can use to distribute messages/events across your system.\nDesign How will it work? It will accept registering subscribers (other microservices). Whenever it gets a message from a microservice, it will send it further to all subscribers, using a REST call to the other microservices /event URL.","keywords":["architecture","event","go","golang","message","microservice","subscription"],"articleBody":"Introduction In our microservice architectures we always need a method for communicating between services. There are various ways to achieve this. Few of them are, but are not limited to: Remote Procedure Call, REST API’s, message BUSses. In this comprehensive tutorial we’ll write a service, which you can use to distribute messages/events across your system.\nDesign How will it work? It will accept registering subscribers (other microservices). Whenever it gets a message from a microservice, it will send it further to all subscribers, using a REST call to the other microservices /event URL.\nSubscribers will need to call a keep-alive URL regularly, otherwise they will get removed from the subscriber list. This protects us from sending messages to too many ghost subscribers.\nImplementation Let’s start with a basic structure. We’ll define the API and set up our two main data structures:\nThe subscriber list with their register/lastKeepAlive dates. The mutex controlling access to our subscriber list. package main import ( \"net/http\" \"time\" \"sync\" \"fmt\" \"net/url\" \"io/ioutil\" \"bytes\" ) var registeredServiceStorage map[string]time.Time var serviceStorageMutex sync.RWMutex func main() { registeredServiceStorage = make(map[string]time.Time) serviceStorageMutex = sync.RWMutex{} http.HandleFunc(\"/registerAndKeepAlive\", registerAndKeepAlive) http.HandleFunc(\"/deregister\", deregister) http.HandleFunc(\"/sendMessage\", handleMessage) http.HandleFunc(\"/listSubscribers\", handleSubscriberListing) go killZombieServices() http.ListenAndServe(\":3000\", nil) } func registerAndKeepAlive(w http.ResponseWriter, r *http.Request) { } func deregister(w http.ResponseWriter, r *http.Request) { } func handleMessage(w http.ResponseWriter, r *http.Request) { } func sendMessageToSubscriber(data []byte, address string) { } func handleSubscriberListing(w http.ResponseWriter, r *http.Request) { } func killZombieServices() { } We initialize our subscriber list and mutex, and also launch, on another thread, a function that will regularly delete ghost subscribers.\nSo far so good!\nWe can now start getting into each functions implementation.\nWe can begin with the registerAndKeepAlive which does both things. Registering a new subscriber, or updating an existing one. This works because in both cases we just update the map entry with the subscriber address to contain the current time.\nfunc registerAndKeepAlive(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { //Subscriber registration } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } The register function should be called with a POST request. That’s why the first thing we do, is checking if the method is right, otherwise we answer with an error. If it’s ok, then we register the client:\nif r.Method == http.MethodPost { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } if len(values.Get(\"address\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input address.\") return } } We check if the URL arguments are correct, and finally register the subscriber:\nif len(values.Get(\"address\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input address.\") return } serviceStorageMutex.Lock() registeredServiceStorage[values.Get(\"address\")] = time.Now() serviceStorageMutex.Unlock() fmt.Fprint(w, \"success\") Awesome!\nLet’s now implement the function which shall delete the entry when the subscriber wants to deregister.\nfunc deregister(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodDelete { values, err := url.ParseQuery(r.URL.RawQuery) if err != nil { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\", err) return } if len(values.Get(\"address\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input address.\") return } //Subscriber deletion will come here } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only DELETE accepted\") } } Again do we check if the request method is good and if the address argument is correct. If that’s the case, then we can remove this client from our subscriber list.\nif len(values.Get(\"address\")) == 0 { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error:\",\"Wrong input address.\") return } serviceStorageMutex.Lock() delete(registeredServiceStorage, values.Get(\"address\")) serviceStorageMutex.Unlock() fmt.Fprint(w, \"success\") Now it’s time for the main functionality. Namely handling messages and sending them to all subscribers:\nfunc handleMessage(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodPost { } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only POST accepted\") } } As usual, we check if the request method is correct.\nThen, we read the data we got, so we can pass it to multiple concurrent sending functions.\nif r.Method == http.MethodPost { data, err := ioutil.ReadAll(r.Body) if err != nil { fmt.Println(err) } //... } We then lock the mutex for read. That’s important so that we can handle huge amounts of messages efficiently. Basically, it means that we allow others to read while we are reading, because concurrent reading is supported by maps. We can use this unless there’s no one modifying the map.\nWhile we lock the map for read, we check the list of subscribers we have to send the message to, and start concurrent functions that will do the sending. As we don’t want to lock the map for the entire sending time, we only need the addresses.\ndata, err := ioutil.ReadAll(r.Body) if err != nil { fmt.Println(err) } serviceStorageMutex.RLock() for address, _ := range registeredServiceStorage { go sendMessageToSubscriber(data, address) } serviceStorageMutex.RUnlock() fmt.Fprint(w, \"success\") Which means we now have to implement the sendMessageToSubscriber(…) function.\nIt’s pretty simple, we just make a post, and print an error if it happened.\nfunc sendMessageToSubscriber(data []byte, address string) { _, err := http.Post(\"http://\" + address + \"/event\", \"\", bytes.NewBuffer(data)) if err != nil { fmt.Println(err) } } It’s important to notice, that we have to create a buffer from the data, as the http.Post(…) function needs a reader type data structure.\nWe’ll also implement the function which makes it possible to list all the subscribers. Mainly for debugging purposes. There’s nothing new in it. We check if the method is alright, lock the mutex for read, and finally print the map with a correct format of the register time.\nfunc handleSubscriberListing(w http.ResponseWriter, r *http.Request) { if r.Method == http.MethodGet { serviceStorageMutex.RLock() for address, registerTime := range registeredServiceStorage { fmt.Fprintln(w, address, \" : \", registerTime.Format(time.RFC3339)) } serviceStorageMutex.RUnlock() } else { w.WriteHeader(http.StatusBadRequest) fmt.Fprint(w, \"Error: Only GET accepted\") } } Now there’s only one function left. The one that will make sure no ghost services stay for too long. It will check all the services once per minute. This way we’re making it cheap on performance:\nfunc killZombieServices() { t := time.Tick(1 * time.Minute) for range t { } } This is a nice way to launch the code every minute. We create a channel which will send us the time every minute, and range over it, ignoring the received values.\nWe can now get the check and remove working.\nfor range t { timeNow := time.Now() serviceStorageMutex.Lock() for address, timeKeepAlive := range registeredServiceStorage { if timeNow.Sub(timeKeepAlive).Minutes() \u003e 2 { delete(registeredServiceStorage, address) } } serviceStorageMutex.Unlock() } We just range over the subscribers and delete those that haven’t kept their subscription alive.\nTo add to that, if you wanted you could first make a read-only pass over the subscribers, and immediately after that, make a write-locked deletion of the ones you found. This would allow others to read the map while you’re finding subscribers to delete.\nConclusion That’s all! Have fun with creating an infrastructure based on such a service!\n","wordCount":"1110","inLanguage":"en","datePublished":"2016-04-04T10:30:24Z","dateModified":"2016-04-04T10:30:24Z","author":{"@type":"Person","name":"Jacob Martin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jacobmartins.com/2016/04/04/practical-golang-event-multicastsubscription-service/"},"publisher":{"@type":"Organization","name":"Jacob Martin","logo":{"@type":"ImageObject","url":"https://jacobmartins.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://jacobmartins.com/ accesskey=h title="Jacob Martin (Alt + H)">Jacob Martin</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://jacobmartins.com/ title="About Me"><span>About Me</span></a></li><li><a href=https://jacobmartins.com/archive title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jacobmartins.com/>Home</a>&nbsp;»&nbsp;<a href=https://jacobmartins.com/posts/>Posts</a></div><h1 class=post-title>Practical Golang: Event multicast/subscription service</h1><div class=post-meta>April 4, 2016&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Jacob Martin&nbsp;|&nbsp;<a href=https://github.com/cube2222/cube2222.github.io/content/posts/2016-04-04-practical-golang-event-multicastsubscription-service.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In our microservice architectures we always need a method for communicating between services. There are various ways to achieve this. Few of them are, but are not limited to: <em>Remote Procedure Call</em>, <em>REST API’s</em>, <em>message BUSses</em>. In this comprehensive tutorial we’ll write a service, which you can use to distribute messages/events across your system.</p><h3 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h3><p>How will it work? It will accept registering subscribers (other microservices). Whenever it gets a message from a microservice, it will send it further to all subscribers, using a REST call to the other microservices /event URL.</p><p>Subscribers will need to call a <em>keep-alive</em> URL regularly, otherwise they will get removed from the subscriber list. This protects us from sending messages to too many ghost subscribers.</p><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>Let’s start with a basic structure. We’ll define the <strong>API</strong> and set up our two main data structures:</p><ol><li>The <strong><em>subscriber list</em></strong> with their register/lastKeepAlive dates.</li><li>The <strong><em>mutex</em></strong> controlling access to our subscriber list.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/http&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;time&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;net/url&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;io/ioutil&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>registeredServiceStorage</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>serviceStorageMutex</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>registeredServiceStorage</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>serviceStorageMutex</span> = <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>RWMutex</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/registerAndKeepAlive&#34;</span>, <span style=color:#a6e22e>registerAndKeepAlive</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/deregister&#34;</span>, <span style=color:#a6e22e>deregister</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/sendMessage&#34;</span>, <span style=color:#a6e22e>handleMessage</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandleFunc</span>(<span style=color:#e6db74>&#34;/listSubscribers&#34;</span>, <span style=color:#a6e22e>handleSubscriberListing</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>killZombieServices</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:3000&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>registerAndKeepAlive</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deregister</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleMessage</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sendMessageToSubscriber</span>(<span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>address</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleSubscriberListing</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>killZombieServices</span>() {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We initialize our subscriber list and mutex, and also launch, on another thread, a function that will regularly delete <em>ghost subscribers</em>.</p><p>So far so good!<br>We can now start getting into each functions implementation.</p><p>We can begin with the registerAndKeepAlive which does both things. Registering a new subscriber, or updating an existing one. This works because in both cases we just update the map entry with the subscriber address to contain the current time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>registerAndKeepAlive</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Subscriber registration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only POST accepted&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The register function should be called with a <strong>POST</strong> request. That’s why the first thing we do, is checking if the method is right, otherwise we answer with an error. If it’s ok, then we register the client:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>ParseQuery</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>RawQuery</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;address&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>,<span style=color:#e6db74>&#34;Wrong input address.&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We check if the <em>URL arguments</em> are correct, and finally register the subscriber:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;address&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>,<span style=color:#e6db74>&#34;Wrong input address.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>registeredServiceStorage</span>[<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;address&#34;</span>)] = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;success&#34;</span>)
</span></span></code></pre></div><p>Awesome!</p><p>Let’s now implement the function which shall delete the entry when the subscriber wants to deregister.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>deregister</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodDelete</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>values</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>ParseQuery</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>RawQuery</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;address&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>,<span style=color:#e6db74>&#34;Wrong input address.&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//Subscriber deletion will come here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only DELETE accepted&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Again do we check if the <em>request method</em> is good and if the <em>address</em> argument is correct. If that’s the case, then we can remove this client from our subscriber list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;address&#34;</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error:&#34;</span>,<span style=color:#e6db74>&#34;Wrong input address.&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>delete(<span style=color:#a6e22e>registeredServiceStorage</span>, <span style=color:#a6e22e>values</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;address&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;success&#34;</span>)
</span></span></code></pre></div><p>Now it’s time for the main functionality. Namely handling messages and sending them to all subscribers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleMessage</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only POST accepted&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As usual, we check if the request method is correct.</p><p>Then, we read the data we got, so we can pass it to multiple concurrent sending functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodPost</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Body</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>We then lock the mutex <strong><em>for read</em></strong>. That’s important so that we can handle huge amounts of messages efficiently. Basically, it means that we allow others to read while we are reading, because concurrent reading is supported by maps. We can use this unless there’s no one modifying the map.</p><p>While we lock the map for read, we check the list of subscribers we have to send the message to, and start concurrent functions that will do the sending. As we don’t want to lock the map for the entire sending time, we only need the addresses.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadAll</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Body</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>RLock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>registeredServiceStorage</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>sendMessageToSubscriber</span>(<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>address</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>RUnlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;success&#34;</span>)
</span></span></code></pre></div><p>Which means we now have to implement the <em>sendMessageToSubscriber(…)</em> function.</p><p>It’s pretty simple, we just make a post, and print an error if it happened.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sendMessageToSubscriber</span>(<span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>address</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Post</span>(<span style=color:#e6db74>&#34;http://&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>address</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/event&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>(<span style=color:#a6e22e>data</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It’s important to notice, that we have to create a <em>buffer</em> from the data, as the <em>http.Post(…)</em> function needs a reader type data structure.</p><p>We’ll also implement the function which makes it possible to list all the subscribers. Mainly for debugging purposes. There’s nothing new in it. We check if the method is alright, lock the mutex for read, and finally print the map with a correct format of the register time.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleSubscriberListing</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Method</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>MethodGet</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>RLock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>registerTime</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>registeredServiceStorage</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintln</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>address</span>, <span style=color:#e6db74>&#34; : &#34;</span>, <span style=color:#a6e22e>registerTime</span>.<span style=color:#a6e22e>Format</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>RFC3339</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>RUnlock</span>()
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error: Only GET accepted&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now there’s only one function left. The one that will make sure no ghost services stay for too long. It will check all the services once per minute. This way we’re making it cheap on performance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>killZombieServices</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Tick</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Minute</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>t</span> {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a nice way to launch the code every minute. We create a channel which will send us the time every minute, and range over it, ignoring the received values.</p><p>We can now get the check and remove working.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>t</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>timeNow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>timeKeepAlive</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>registeredServiceStorage</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>timeNow</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>timeKeepAlive</span>).<span style=color:#a6e22e>Minutes</span>() &gt; <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>            delete(<span style=color:#a6e22e>registeredServiceStorage</span>, <span style=color:#a6e22e>address</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>serviceStorageMutex</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We just range over the subscribers and delete those that haven’t kept their subscription alive.</p><p>To add to that, if you wanted you could first make a read-only pass over the subscribers, and immediately after that, make a <strong>write-locked</strong> deletion of the ones you found. This would allow others to read the map while you’re finding subscribers to delete.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>That’s all! Have fun with creating an infrastructure based on such a service!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jacobmartins.com/tags/architecture/>architecture</a></li><li><a href=https://jacobmartins.com/tags/event/>event</a></li><li><a href=https://jacobmartins.com/tags/go/>go</a></li><li><a href=https://jacobmartins.com/tags/golang/>golang</a></li><li><a href=https://jacobmartins.com/tags/message/>message</a></li><li><a href=https://jacobmartins.com/tags/microservice/>microservice</a></li><li><a href=https://jacobmartins.com/tags/subscription/>subscription</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Practical Golang: Event multicast/subscription service on twitter" href="https://twitter.com/intent/tweet/?text=Practical%20Golang%3a%20Event%20multicast%2fsubscription%20service&url=https%3a%2f%2fjacobmartins.com%2f2016%2f04%2f04%2fpractical-golang-event-multicastsubscription-service%2f&hashtags=architecture%2cevent%2cgo%2cgolang%2cmessage%2cmicroservice%2csubscription"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Practical Golang: Event multicast/subscription service on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjacobmartins.com%2f2016%2f04%2f04%2fpractical-golang-event-multicastsubscription-service%2f&title=Practical%20Golang%3a%20Event%20multicast%2fsubscription%20service&summary=Practical%20Golang%3a%20Event%20multicast%2fsubscription%20service&source=https%3a%2f%2fjacobmartins.com%2f2016%2f04%2f04%2fpractical-golang-event-multicastsubscription-service%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Practical Golang: Event multicast/subscription service on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjacobmartins.com%2f2016%2f04%2f04%2fpractical-golang-event-multicastsubscription-service%2f&title=Practical%20Golang%3a%20Event%20multicast%2fsubscription%20service"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Practical Golang: Event multicast/subscription service on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjacobmartins.com%2f2016%2f04%2f04%2fpractical-golang-event-multicastsubscription-service%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Practical Golang: Event multicast/subscription service on whatsapp" href="https://api.whatsapp.com/send?text=Practical%20Golang%3a%20Event%20multicast%2fsubscription%20service%20-%20https%3a%2f%2fjacobmartins.com%2f2016%2f04%2f04%2fpractical-golang-event-multicastsubscription-service%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Practical Golang: Event multicast/subscription service on telegram" href="https://telegram.me/share/url?text=Practical%20Golang%3a%20Event%20multicast%2fsubscription%20service&url=https%3a%2f%2fjacobmartins.com%2f2016%2f04%2f04%2fpractical-golang-event-multicastsubscription-service%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://jacobmartins.com/>Jacob Martin</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>